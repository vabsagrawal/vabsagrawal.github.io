{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Java oops Concepts Encapsulation Encapsulation is one of the four fundamental OOP concepts. The other three are inheritance, polymorphism, and abstraction. Encapsulation in Java is a mechanism of wrapping the data (variables) and code acting on the data (methods) together as as single unit. In encapsulation the variables of a class will be hidden from other classes, and can be accessed only through the methods of their current class, therefore it is also known as data hiding. To achieve encapsulation in Java : Declare the variables of a class as private. Provide public setter and getter methods to modify and view the variables values. Inheritance Inheritance can be defined as the process where one class acquires the properties (methods and fields) of another. With the use of inheritance the information is made manageable in a hierarchical order. The class which inherits the properties of other is known as subclass (derived class, child class) and the class whose properties are inherited is known as superclass (base class, parent class). extends is the keyword used to inherit the properties of a class. Below given is the syntax of extends keyword. Polymorphism Polymorphism is the concept where an object behaves differently in different situations. There are two types of polymorphism \u2013 compile time polymorphism and runtime polymorphism. Compile time polymorphism is achieved by method overloading. For example, we can have a class as below. public class Circle { public void draw(){ System.out.println(\"Drwaing circle with default color Black and diameter 1 cm.\"); } public void draw(int diameter){ System.out.println(\"Drwaing circle with default color Black and diameter\"+diameter+\" cm.\"); } public void draw(int diameter, String color){ System.out.println(\"Drwaing circle with color\"+color+\" and diameter\"+diameter+\" cm.\"); } } Here we have multiple draw methods but they have different behavior. This is a case of method overloading because all the methods name is same and arguments are different. Here compiler will be able to identify the method to invoke at compile time, hence it\u2019s called compile time polymorphism. Runtime polymorphism is implemented when we have \u201cIS-A\u201d relationship between objects. This is also called as method overriding because subclass has to override the superclass method for runtime polymorphism. If we are working in terms of superclass, the actual implementation class is decided at runtime. Compiler is not able to decide which class method will be invoked. This decision is done at runtime, hence the name as runtime polymorphism or dynamic method dispatch. package com.test; public interface Shape { public void draw(); } package com.test; public class Circle implements Shape{ @Override public void draw(){ System.out.println(\"Drwaing circle\"); } } package com.test; public class Square implements Shape { @Override public void draw() { System.out.println(\"Drawing Square\"); } } Shape is the superclass and there are two subclasses Circle and Square. Below is an example of runtime polymorphism. Shape sh = new Circle(); sh.draw(); Shape sh1 = getShape(); //some third party logic to determine shape sh1.draw(); In above examples, java compiler don\u2019t know the actual implementation class of Shape that will be used at runtime, hence runtime polymorphism. Abstraction In Object oriented programming Abstraction is a process process of hiding the implementation details from the user, only the functionality will be provided to the user. In other words user will have the information on what the object does instead of how it does it. In Java Abstraction is achieved using Abstract classes and Interfaces. A class which contains the abstract keyword in its declaration is known as abstract class. An interface is a reference type in Java, it is similar to class, it is a collection of abstract methods. A class implements an interface, thereby inheriting the abstract methods of the interface. Along with abstract methods an interface may also contain constants, default methods, static methods, and nested types. Method bodies exist only for default methods and static methods. Writing an interface is similar to writing a class. But a class describes the attributes and behaviours of an object. And an interface contains behaviours that a class implements. Unless the class that implements the interface is abstract, all the methods of the interface need to be defined in the class. An interface is similar to a class in the following ways: An interface can contain any number of methods. An interface is written in a file with a .java extension, with the name of the interface matching the name of the file. The byte code of an interface appears in a .class file. Interfaces appear in packages, and their corresponding bytecode file must be in a directory structure that matches the package name. However, an interface is different from a class in several ways, including: You cannot instantiate an interface. An interface does not contain any constructors. All of the methods in an interface are abstract. An interface cannot contain instance fields. The only fields that can appear in an interface must be declared both static and final. An interface is not extended by a class; it is implemented by a class. An interface can extend multiple interfaces. Refrences https://www.google.com https://www.tutorialspoint.com","title":"Java oops Concepts"},{"location":"#java-oops-concepts","text":"","title":"Java oops Concepts"},{"location":"#encapsulation","text":"Encapsulation is one of the four fundamental OOP concepts. The other three are inheritance, polymorphism, and abstraction. Encapsulation in Java is a mechanism of wrapping the data (variables) and code acting on the data (methods) together as as single unit. In encapsulation the variables of a class will be hidden from other classes, and can be accessed only through the methods of their current class, therefore it is also known as data hiding. To achieve encapsulation in Java : Declare the variables of a class as private. Provide public setter and getter methods to modify and view the variables values.","title":"Encapsulation"},{"location":"#inheritance","text":"Inheritance can be defined as the process where one class acquires the properties (methods and fields) of another. With the use of inheritance the information is made manageable in a hierarchical order. The class which inherits the properties of other is known as subclass (derived class, child class) and the class whose properties are inherited is known as superclass (base class, parent class). extends is the keyword used to inherit the properties of a class. Below given is the syntax of extends keyword.","title":"Inheritance"},{"location":"#polymorphism","text":"Polymorphism is the concept where an object behaves differently in different situations. There are two types of polymorphism \u2013 compile time polymorphism and runtime polymorphism. Compile time polymorphism is achieved by method overloading. For example, we can have a class as below. public class Circle { public void draw(){ System.out.println(\"Drwaing circle with default color Black and diameter 1 cm.\"); } public void draw(int diameter){ System.out.println(\"Drwaing circle with default color Black and diameter\"+diameter+\" cm.\"); } public void draw(int diameter, String color){ System.out.println(\"Drwaing circle with color\"+color+\" and diameter\"+diameter+\" cm.\"); } } Here we have multiple draw methods but they have different behavior. This is a case of method overloading because all the methods name is same and arguments are different. Here compiler will be able to identify the method to invoke at compile time, hence it\u2019s called compile time polymorphism. Runtime polymorphism is implemented when we have \u201cIS-A\u201d relationship between objects. This is also called as method overriding because subclass has to override the superclass method for runtime polymorphism. If we are working in terms of superclass, the actual implementation class is decided at runtime. Compiler is not able to decide which class method will be invoked. This decision is done at runtime, hence the name as runtime polymorphism or dynamic method dispatch. package com.test; public interface Shape { public void draw(); } package com.test; public class Circle implements Shape{ @Override public void draw(){ System.out.println(\"Drwaing circle\"); } } package com.test; public class Square implements Shape { @Override public void draw() { System.out.println(\"Drawing Square\"); } } Shape is the superclass and there are two subclasses Circle and Square. Below is an example of runtime polymorphism. Shape sh = new Circle(); sh.draw(); Shape sh1 = getShape(); //some third party logic to determine shape sh1.draw(); In above examples, java compiler don\u2019t know the actual implementation class of Shape that will be used at runtime, hence runtime polymorphism.","title":"Polymorphism"},{"location":"#abstraction","text":"In Object oriented programming Abstraction is a process process of hiding the implementation details from the user, only the functionality will be provided to the user. In other words user will have the information on what the object does instead of how it does it. In Java Abstraction is achieved using Abstract classes and Interfaces. A class which contains the abstract keyword in its declaration is known as abstract class. An interface is a reference type in Java, it is similar to class, it is a collection of abstract methods. A class implements an interface, thereby inheriting the abstract methods of the interface. Along with abstract methods an interface may also contain constants, default methods, static methods, and nested types. Method bodies exist only for default methods and static methods. Writing an interface is similar to writing a class. But a class describes the attributes and behaviours of an object. And an interface contains behaviours that a class implements. Unless the class that implements the interface is abstract, all the methods of the interface need to be defined in the class. An interface is similar to a class in the following ways: An interface can contain any number of methods. An interface is written in a file with a .java extension, with the name of the interface matching the name of the file. The byte code of an interface appears in a .class file. Interfaces appear in packages, and their corresponding bytecode file must be in a directory structure that matches the package name. However, an interface is different from a class in several ways, including: You cannot instantiate an interface. An interface does not contain any constructors. All of the methods in an interface are abstract. An interface cannot contain instance fields. The only fields that can appear in an interface must be declared both static and final. An interface is not extended by a class; it is implemented by a class. An interface can extend multiple interfaces.","title":"Abstraction"},{"location":"#refrences","text":"https://www.google.com https://www.tutorialspoint.com","title":"Refrences"},{"location":"page1/","text":"Page1","title":"Page1"},{"location":"page1/#page1","text":"","title":"Page1"},{"location":"rssvsz/","text":"Analogy-1 RSS is the Resident Set Size and is used to show how much memory is allocated to that process and is in RAM. It does not include memory that is swapped out. It does include memory from shared libraries as long as the pages from those libraries are actually in memory. It does include all stack and heap memory. VSZ is the Virtual Memory Size. It includes all memory that the process can access, including memory that is swapped out, memory that is allocated, but not used, and memory that is from shared libraries. So if process A has a 500K binary and is linked to 2500K of shared libraries, has 200K of stack/heap allocations of which 100K is actually in memory (rest is swapped or unused), and it has only actually loaded 1000K of the shared libraries and 400K of its own binary then: RSS: 400K + 1000K + 100K = 1500K VSZ: 500K + 2500K + 200K = 3200K Since part of the memory is shared, many processes may use it, so if you add up all of the RSS values you can easily end up with more space than your system has. The memory that is allocated also may not be in RSS until it is actually used by the program. So if your program allocated a bunch of memory up front, then uses it over time, you could see RSS going up and VSZ staying the same. There is also PSS (proportional set size). This is a newer measure which tracks the shared memory as a proportion used by the current process. So if there were two processes using the same shared library from before: PSS: 400K + (1000K/2) + 100K = 400K + 500K + 100K = 1000K Threads all share the same address space, so the RSS, VSZ and PSS for each thread is identical to all of the other threads in the process. Use ps or top to view this information in linux/unix. Analogy-2 This article explains three indicators that can possibly be used to measure the memory consumption of a single process on Linux. VSZ (Virtual Memory Size), RSS (Resident Set Size), and PSS (Proportional Set Size). Although this will lack accuracy, let us consider an allegory to get the idea. There are three people sharing a room. We will consider each person to represent a process, and living expenses to represent memory consumption. Measuring the memory consumption of a single process will be represented as calculating the total living expense for one person in this allegory. Each person has their own cell phone line that is not being shared. All three indicators, VSZ, RSS, and PSS, will count the cell phone bills as each persons living expense individually, and there is no problem with this. The shared room comes with a garage space that can be used if they pay for it, but they all don't drive and they are not using it. However, VSZ will count the entire garage space cost as each persons living expense even though they are not using it. VSZ, therefore, represents the total living expense when they spend on every possible thing regardless of the actual usage. RSS and PSS only count expenses that are actually being used, and therefore, they will not count the garage space cost because it is not being used. Since they are sharing the internet connection and the cable TV, they split up those bills. However, RSS will count the entire amount of the internet connection and cable TV as each persons living expense, even though they are sharing it and splitting up the bill. The idea of RSS is to calculate living expenses as it was not shared with anybody else. PSS will only count one third of the internet connection and cable TV bill as each persons living expense, because they are sharing it. This is more reasonable than RSS since it is considers the fact that they are sharing it. Let's make the allegory a little bit more complicated in order to understand the limitations of PSS. One person is always on the internet and doesn't watch TV that much. Hence, that person pays 50% of the internet connection bill and 20% of the cable TV bill upon agreement. PSS, however, cannot handle situations like this. It will simply calculate one third of the internet connection bill and cable TV bill as each persons living expense. Using PSS is what I consider most reasonable. However, there are limitations and there are also situations where RSS may work better. RSS is reasonable when you want to know the total living expense when you move out and live on your own. Refrences https://www.google.com https://web.archive.org/web/20120520221529/http://emilics.com/blog/article/mconsumption.html http://manpages.ubuntu.com/manpages/en/man1/ps.1.html https://web.archive.org/web/20120520221529/http://emilics.com/blog/article/mconsumption.html","title":"Memory RSS vs VSZ"},{"location":"rssvsz/#analogy-1","text":"RSS is the Resident Set Size and is used to show how much memory is allocated to that process and is in RAM. It does not include memory that is swapped out. It does include memory from shared libraries as long as the pages from those libraries are actually in memory. It does include all stack and heap memory. VSZ is the Virtual Memory Size. It includes all memory that the process can access, including memory that is swapped out, memory that is allocated, but not used, and memory that is from shared libraries. So if process A has a 500K binary and is linked to 2500K of shared libraries, has 200K of stack/heap allocations of which 100K is actually in memory (rest is swapped or unused), and it has only actually loaded 1000K of the shared libraries and 400K of its own binary then: RSS: 400K + 1000K + 100K = 1500K VSZ: 500K + 2500K + 200K = 3200K Since part of the memory is shared, many processes may use it, so if you add up all of the RSS values you can easily end up with more space than your system has. The memory that is allocated also may not be in RSS until it is actually used by the program. So if your program allocated a bunch of memory up front, then uses it over time, you could see RSS going up and VSZ staying the same. There is also PSS (proportional set size). This is a newer measure which tracks the shared memory as a proportion used by the current process. So if there were two processes using the same shared library from before: PSS: 400K + (1000K/2) + 100K = 400K + 500K + 100K = 1000K Threads all share the same address space, so the RSS, VSZ and PSS for each thread is identical to all of the other threads in the process. Use ps or top to view this information in linux/unix.","title":"Analogy-1"},{"location":"rssvsz/#analogy-2","text":"This article explains three indicators that can possibly be used to measure the memory consumption of a single process on Linux. VSZ (Virtual Memory Size), RSS (Resident Set Size), and PSS (Proportional Set Size). Although this will lack accuracy, let us consider an allegory to get the idea. There are three people sharing a room. We will consider each person to represent a process, and living expenses to represent memory consumption. Measuring the memory consumption of a single process will be represented as calculating the total living expense for one person in this allegory. Each person has their own cell phone line that is not being shared. All three indicators, VSZ, RSS, and PSS, will count the cell phone bills as each persons living expense individually, and there is no problem with this. The shared room comes with a garage space that can be used if they pay for it, but they all don't drive and they are not using it. However, VSZ will count the entire garage space cost as each persons living expense even though they are not using it. VSZ, therefore, represents the total living expense when they spend on every possible thing regardless of the actual usage. RSS and PSS only count expenses that are actually being used, and therefore, they will not count the garage space cost because it is not being used. Since they are sharing the internet connection and the cable TV, they split up those bills. However, RSS will count the entire amount of the internet connection and cable TV as each persons living expense, even though they are sharing it and splitting up the bill. The idea of RSS is to calculate living expenses as it was not shared with anybody else. PSS will only count one third of the internet connection and cable TV bill as each persons living expense, because they are sharing it. This is more reasonable than RSS since it is considers the fact that they are sharing it. Let's make the allegory a little bit more complicated in order to understand the limitations of PSS. One person is always on the internet and doesn't watch TV that much. Hence, that person pays 50% of the internet connection bill and 20% of the cable TV bill upon agreement. PSS, however, cannot handle situations like this. It will simply calculate one third of the internet connection bill and cable TV bill as each persons living expense. Using PSS is what I consider most reasonable. However, there are limitations and there are also situations where RSS may work better. RSS is reasonable when you want to know the total living expense when you move out and live on your own.","title":"Analogy-2"},{"location":"rssvsz/#refrences","text":"https://www.google.com https://web.archive.org/web/20120520221529/http://emilics.com/blog/article/mconsumption.html http://manpages.ubuntu.com/manpages/en/man1/ps.1.html https://web.archive.org/web/20120520221529/http://emilics.com/blog/article/mconsumption.html","title":"Refrences"},{"location":"sub-page1/","text":"sub-page1","title":"sub-page1"},{"location":"sub-page1/#sub-page1","text":"","title":"sub-page1"}]}